var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#Exported-Functions-and-Types","page":"API","title":"Exported Functions and Types","text":"","category":"section"},{"location":"api/#LowLevelParticleFilters.KalmanFilter-Tuple{ModelingToolkitBase.System, Any, Any}","page":"API","title":"LowLevelParticleFilters.KalmanFilter","text":"kf, x_sym, ps, iosys, mats, prob = KalmanFilter(model::System, inputs, outputs; disturbance_inputs, Ts, R1, R2, x0map=[], pmap=[], σ0 = 1e-4, init=false, static=true, split = true, simplify=true, discretize = true, parametric = false, kwargs...)\n\nConstruct a Kalman filter for a linear MTK ODESystem. No check is performed to verify that the system is truly linear, if it is nonlinear, it will be linearized.\n\nReturns:\n\nkf: A Kalman filter. If parametric=true, the A,B,C,D,R1,R2 fields are all functions of (x,u,p,t), otherwise they are matrices that are evaluated at the x0map, pmap values.\nx_sym: The symbolic state variables of the system.\nps: The symbolic parameters of the system.\niosys: The simplified MTK System\nmats: A named tuple containing the symbolic system matrices (A,B,C,D,Bw,Dw), where Bw and Dw are the input matrices corresponding to the disturbance inputs.\nprob: A StateEstimationProblem object. This problem object does not play quite the same role as when using Unscented or Extended Kalman filters since the filter is created already by this constructor, but the problem object can still be useful for inspecting the simplified MTK system, to create EstimatedOutput objects and to make use of the symbolic indexing functionality.\n\nArguments:\n\nmodel: An MTK System model, this model must not have undergone structural simplification.\ninputs: The inputs to the dynamical system, a vector of symbolic variables.\noutputs: The outputs of the dynamical system, a vector of symbolic variables.\ndisturbance_inputs: The disturbance inputs to the dynamical system, a vector of symbolic variables. These disturbance inputs indicate where dynamics noise w enters the system. The probability distribution R1 is defined over these variables.\nTs: The discretization time step.\nR1: The covariance matrix of the dynamics noise w.\nR2: The covariance matrix of the measurement noise e.\nx0map: A dictionary mapping symbolic variables to their initial values. If a variable is not provided, it is assumed to be initialized to zero.  The value can be a scalar number, in which case the covariance of the initial state is set to σ0^2*I(nx), and the value can be a Distributions.Normal, in which case the provided distributions are used as the distribution of the initial state. When passing distributions, all state variables must be provided values.\npmap: A dictionary mapping symbolic variables to their values.\nσ0: The standard deviation of the initial state. This is used when x0map is not provided.\ninit: If true, the initial state is computed using an initialization problem. If false, the initial state is computed using the get_u0 function.\nstatic: If true, static arrays are used for the state and covariance matrix. This can improve performance for small systems.\nsplit: Passed to mtkcompile, see the documentation there.\nsimplify: Passed to mtkcompile, see the documentation there.\ndiscretize: If true, the system is discretized using zero-order hold. If false, matrices/functions are generated for the continuous-time system, in which case the user must handle discretization themselves (filtering with a continuous-time system without discretization will yield nonsensical results).\nparametric_A: If true, the A field of the returned filter is a function of (x,u,p,t), otherwise it is a matrix that is evaluated at the x0map, pmap values.\nparametric_B: If true, the B field of the returned filter is a function of (x,u,p,t), otherwise it is a matrix that is evaluated at the x0map, pmap values.\nparametric_C: If true, the C field of the returned filter is a function of (x,u,p,t), otherwise it is a matrix that is evaluated at the x0map, pmap values.\nparametric_D: If true, the D field of the returned filter is a function of (x,u,p,t), otherwise it is a matrix that is evaluated at the x0map, pmap values.\nparametric_R1: If true, the R1 field of the returned filter is a function of (x,u,p,t), otherwise it is a matrix that is evaluated at the x0map, pmap values.\nparametric_R2: If true, the R2 field of the returned filter is a function of (x,u,p,t), otherwise it is a matrix that is evaluated at the x0map, pmap values.\ntuplify: If true, the parameter vector p is returned as a tuple instead of an array. This can improve performance for filters with a small number of parameters of heterogeneous types.\nkwargs: Additional keyword arguments passed to mtkcompile.\n\n\n\n\n\n","category":"method"},{"location":"api/#LowLevelParticleFiltersMTK.EstimatedOutput","page":"API","title":"LowLevelParticleFiltersMTK.EstimatedOutput","text":"EstimatedOutput(kf, prob, sym)\n\nCreate an output function that can be called like\n\ng(x::Vector,    u, p, t)     # Compute an output\ng(xR::MvNormal, u, p, t)     # Compute an output distribution given input distribution xR\ng(kf,           u, p, t)     # Compute an output distribution given the current state of an AbstractKalmanFilter\n\nArguments:\n\nkf: A Kalman type filter\nprob: A StateEstimationProblem object\nsym: A symbolic expression or vector of symbolic expressions that the function should output.\n\n\n\n\n\n","category":"type"},{"location":"api/#LowLevelParticleFiltersMTK.StateEstimationProblem-Tuple{Any, Any, Any}","page":"API","title":"LowLevelParticleFiltersMTK.StateEstimationProblem","text":"StateEstimationProblem(model, inputs, outputs; disturbance_inputs, discretization, Ts, df, dg, x0map=[], pmap=[], init=false)\n\nA structure representing a state-estimation problem.\n\nArguments:\n\nmodel: An MTK ODESystem model, this model must not have undergone structural simplification.\ninputs: The inputs to the dynamical system, a vector of symbolic variables that must be of type @variables.\noutputs: The outputs of the dynamical system, a vector of symbolic variables that must be of type @variables.\ndisturbance_inputs: The disturbance inputs to the dynamical system, a vector of symbolic variables that must be of type @variables. These disturbance inputs indicate where dynamics noise w enters the system. The probability distribution d_f is defined over these variables.\ndiscretization: A function discretization(f_cont, Ts, x_inds, alg_inds, nu) = f_disc that takes a continuous-time dynamics function f_cont(x,u,p,t) and returns a discrete-time dynamics function f_disc(x,u,p,t). x_inds is the indices of differential state variables, alg_inds is the indices of algebraic variables, and nu is the number of inputs.\nTs: The discretization time step.\ndf: The probability distribution of the dynamics noise w. When using Kalman-type estimators, this must be a MvNormal or SimpleMvNormal distribution.\ndg: The probability distribution of the measurement noise e. When using Kalman-type estimators, this must be a MvNormal or SimpleMvNormal distribution.\nx0map: A dictionary mapping symbolic variables to their initial values. If a variable is not provided, it is assumed to be initialized to zero. The value can be a scalar number, in which case the covariance of the initial state is set to σ0^2*I(nx), and the value can be a Distributions.Normal, in which case the provided distributions are used as the distribution of the initial state. When passing distributions, all state variables must be provided values.\nσ0: The standard deviation of the initial state. This is used when x0map is not provided or when the values in x0map are scalars.\npmap: A dictionary mapping symbolic variables to their values. If a variable is not provided, it is assumed to be initialized to zero.\ninit: If true, the initial state is computed using an initialization problem. If false, the initial state is computed using the get_u0 function.\nxscalemap: A dictionary mapping state variables to scaling factors. This is used to scale the state variables during integration to improve numerical stability. If a variable is not provided, it is assumed to have a scaling factor of 1.0. If provided, discretization is a function with signature discretization(f_cont, Ts, x_inds, alg_inds, nu, scale_x) where scale_x is a vector of scaling factors for the state variables.\n\nUsage:\n\nPseudocode\n\nprob      = StateEstimationProblem(...)\nkf        = get_filter(prob, ExtendedKalmanFilter)      # or UnscentedKalmanFilter\nfiltersol = forward_trajectory(kf, u, y)\nsol       = StateEstimationSolution(filtersol, prob)   # Package into higher-level solution object\nplot(sol, idxs=[prob.state; prob.outputs; prob.inputs]) # Plot the solution\n\n\n\n\n\n","category":"method"},{"location":"api/#LowLevelParticleFiltersMTK.StateEstimationSolution","page":"API","title":"LowLevelParticleFiltersMTK.StateEstimationSolution","text":"StateEstimationSolution(kfsol, prob)\n\nA solution object that provides symbolic indexing to a KalmanFilteringSolution object.\n\nFields:\n\nsol:  a KalmanFilteringSolution object.\nprob: a StateEstimationProblem object.\n\nExample\n\nsol = StateEstimationSolution(kfsol, prob)\nsol[model.x]                 # Index with a variable\nsol[model.y^2]               # Index with an expression\nsol[model.y^2, dist=true]    # Obtain the posterior probability distribution of the provided expression\nsol[model.y^2, Nsamples=100] # Draw 100 samples from the posterior distribution of the provided expression\n\n\n\n\n\n","category":"type"},{"location":"api/#LowLevelParticleFiltersMTK.get_filter-Tuple{StateEstimationProblem, Type{LowLevelParticleFilters.ExtendedKalmanFilter}}","page":"API","title":"LowLevelParticleFiltersMTK.get_filter","text":"get_filter(prob::StateEstimationProblem, ::Type{ExtendedKalmanFilter}; constant_R1=true, kwargs)\nget_filter(prob::StateEstimationProblem, ::Type{UnscentedKalmanFilter}; kwargs)\n\nInstantiate a filter from a state-estimation problem. kwargs are sent to the filter constructor.\n\nIf constant_R1=true, the dynamics noise covariance matrix R1 is assumed to be constant and is computed at the initial state. Otherwise, R1 is computed at each time step throug repeated linearization w.r.t. the disturbance inputs w.\n\n\n\n\n\n","category":"method"},{"location":"api/#LowLevelParticleFiltersMTK.propagate_distribution-Tuple{Any, LowLevelParticleFilters.ExtendedKalmanFilter, Any, Vararg{Any}}","page":"API","title":"LowLevelParticleFiltersMTK.propagate_distribution","text":"propagate_distribution(f, kf, dist, args...; kwargs...)\n\nPropagate a probability distribution dist through a nonlinear function f using the covariance-propagation method of filter kf.\n\nArguments:\n\nf: A nonlinear function f(x, args...; kwargs...) that takes a vector x and returns a vector.\nkf: A state estimator, such as an ExtendedKalmanFilter or UnscentedKalmanFilter.\ndist: A probability distribution, such as a MvNormal or SimpleMvNormal.\nargs: Additional arguments to f.\nkwargs: Additional keyword arguments to f.\n\n\n\n\n\n","category":"method"},{"location":"#LowLevelParticleFiltersMTK","page":"Home","title":"LowLevelParticleFiltersMTK","text":"A helper package for state-estimation workflows using LowLevelParticleFilters.jl with ModelingToolkit models.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package is registered, you can install it using:\n\nimport Pkg; Pkg.add(\"LowLevelParticleFiltersMTK\")","category":"section"},{"location":"#Challenges-with-performing-state-estimation-with-ModelingToolkit-models","page":"Home","title":"Challenges with performing state estimation with ModelingToolkit models","text":"Consider a discrete-time dynamical system for which we want to perform state estimation:\n\nbeginaligned\nx(t+1) = f(x(t) u(t) p t w(t))\ny(t) = g(x(t) u(t) p t e(t))\nendaligned\n\nGetting a ModelingToolkit model into this form requires several steps that are non trivial, such as generating the dynamics and measurement functions, f and g, on the form required by the filter and discretizing a continuous-time model.\n\nWorkflows involving ModelingToolkit also demand symbolic indexing rather than indexing with integers, this need arises due to the fact that the state realization for the system is chosen by MTK rather than by the user, and this realization may change between different versions of MTK. One cannot normally specify the required initial state distribution and the dynamics noise distribution without having knowledge of the state realization. To work around this issue, this package requires the user to explicitly model how the disturbance inputs w are affecting the dynamics, such that the realization of the dynamics noise becomes independent on the chosen state realization. This results in a dynamical model where the dynamics disturbance w is an input to the model\n\ndotx = f(x u p t w)\n\nSome state estimators handle this kind of dynamics natively, like the UnscentedKalmanFilter with AUGD = true, while others, like the ExtendedKalmanFilter require manipulation of this model to work. This package handles such manipulation automatically, e.g., by continuously linearizing f w.r.t. w to obtain B_w(t) and providing the ExtendedKalmanFilter with the time-varying dynamics covariance matrix R_1(x u p t) = B_w(t) R_w B_w(t)^T.\n\nFinally, this package provides symbolic indexing of the solution object, such that one can easily obtain the estimated posterior distribution over any arbitrary variable in the model, including \"observed\" variables that are not part of the state vector being estimated by the estimator.","category":"section"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"tip: Tip\nIt is assumed that the reader is familiar with the basics of LowLevelParticleFilters.jl. Consult the documentation and the video lectures liked therein to obtain such familiarity.\n\nThe workflow can be summarized as follows\n\nDefine a model using ModelingToolkit\nCreate an instance of prob = StateEstimationProblem(...). This problem contains the model as well as specifications of inputs, outputs, disturbance inputs, noise probability distributions and discretization method.\nInstantiate a state estimator using filt = get_filter(prob, FilterConstructor). This calls the filter constructor with the appropriate dynamics functions depending on what type of filter is used.\nPerform state estimation using the filter object as you would normally do with LowLevelParticleFilters.jl. Obtain a fsol::KalmanFilteringSolution object, either from calling LowLevelParticleFilters.forward_trajectory or by creating one manually after having performed custom filtering.\nWrap the fsol object in a sol = StateEstimationSolution(fsol, prob) object. This will provide symbolic indexing capabilities similar to how solution objects work in ModelingToolkit.\nAnalyze the solution object using, e.g., sol[var], plot(sol), plot(sol, idxs=[var1, var2]) etc.\nProfit from your newly derived insight.\n\nAs you can see, the workflow is similar to the standard MTK workflow, but contains a few more manual steps, notably the instantiation of the filter in step 3. and the manual wrapping of the solution object in step 5. The design is made this way since state estimation does not fit neatly into a problem->solve framework, in particular, one may have measurements arriving at irregular intervals, partial measurements, custom modifications of the covariance of the estimator etc. For simple cases where batch filtering (offline) is applicable, the function LowLevelParticleFilters.forward_trajectory produces the required KalmanFilteringSolution object that can be wrapped in a StateEstimationSolution object. Situations that demand more flexibility instead require the user to manually construct this solution object, in which case inspecting the implementation of LowLevelParticleFilters.forward_trajectory and modifying it to suit your needs is a good starting point. An example of this is demonstrated in the tutorial fault detection.","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"The example below demonstrates a complete workflow, annotating the code with comments to point out things that are perhaps non-obvious.\n\nusing LowLevelParticleFiltersMTK\nusing LowLevelParticleFilters\nusing LowLevelParticleFilters: SimpleMvNormal\nusing ModelingToolkit\nusing SeeToDee # used to discretize the dynamics\nusing Plots\nusing StaticArrays\nusing LinearAlgebra\n\nt = ModelingToolkit.t_nounits\nD = ModelingToolkit.D_nounits\n\n@component function SimpleSys(; name)\n    pars = @parameters begin\n    end\n\n    vars = @variables begin\n        x(t) = 2.0\n        u(t) = 0\n        y(t)\n        w(t), [disturbance = true, input = true]\n    end\n\n    equations = [\n        D(x) ~ -x + u + w # Explicitly encode where dynamics noise enters the system with w\n        y ~ x\n    ]\n\n    return ODESystem(equations, t; name)\nend\n\n@named model = SimpleSys()  # Do not use @mtkbuild here\ncmodel  = complete(model)   # complete is required for variable indexing since we did not use @mtkbuild above\ninputs  = [cmodel.u]        # The (unbound) inputs to the system\noutputs = [cmodel.y]        # The outputs for which we obtain measurements\ndisturbance_inputs = [cmodel.w] # The dynamics disturbance inputs to the system\n\nnu = length(inputs)             # Number of inputs\nnw = length(disturbance_inputs) # Number of disturbance inputs\nny = length(outputs)            # Number of measured outputs\nR1 = SMatrix{nw,nw}(0.01I(nw))  # Dynamics noise covariance\nR2 = SMatrix{ny,ny}(0.1I(ny))   # Measurement noise covariance\n\ndf = SimpleMvNormal(R1)         # Dynamics noise distribution. This has to be a Gaussian if using a Kalman-type filter\ndg = SimpleMvNormal(R2)         # Measurement noise distribution. This has to be a Gaussian if using a Kalman-type filter\n\nTs = 0.1                        # Sampling interval\ndiscretization = function (f,Ts,x_inds,alg_inds,nu)\n  isempty(alg_inds) || error(\"Rk4 only handles differential equations, consider `Trapezoidal` instead\")\n  SeeToDee.Rk4(f, Ts) # Discretization method\nend\n\nprob = StateEstimationProblem(model, inputs, outputs; disturbance_inputs, df, dg, discretization, Ts)\n\n# We instantiate two different filters for comparison\nekf = get_filter(prob, ExtendedKalmanFilter)\nukf = get_filter(prob, UnscentedKalmanFilter)\n\n# Simulate some data from the trajectory distribution implied by the model\nu     = [randn(nu) for _ in 1:30] # A random input sequence\nx,u,y = simulate(ekf, u, dynamics_noise=true, measurement_noise=true)\n\n# Perform the filtering in batch since the entire input-output sequence is available\nfsole = forward_trajectory(ekf, u, y)\nfsolu = forward_trajectory(ukf, u, y)\n\n# Wrap the filter solution objects in a StateEstimationSolution object\nsole = StateEstimationSolution(fsole, prob)\nsolu = StateEstimationSolution(fsolu, prob)\n\n## We can access the solution to any variable in the model easily\nsole[cmodel.x] == sole[cmodel.y]\n\n## We can also obtain the solution as a trajectory of probability distributions\nsole[cmodel.x, dist=true]\n\n## We can plot the filter solution object using the plot recipe from LowLevelParticleFilters\nusing Plots\nplot(fsole, size=(1000, 1000))\nplot!(fsole.t, reduce(hcat, x)', lab=\"True x\")\n##\nplot(fsolu, size=(1000, 1000))\nplot!(fsolu.t, reduce(hcat, x)', lab=\"True x\")\n\n## We can also plot the wrapped solution object\nplot(sole)\nplot!(solu)\n\n## The wrapped solution object allows for symbolic indexing,\n# note how we can easily plot the posterior distribution over y^2 + 0.1*sin(u) \nplot(sole, idxs=cmodel.y^2 + 0.1*sin(cmodel.u))\nplot!(solu, idxs=cmodel.y^2 + 0.1*sin(cmodel.u))\nsavefig(\"solution.png\") # hide\nnothing # hide\n\n(Image: solution)","category":"section"},{"location":"#Tips-for-modeling-for-state-estimation","page":"Home","title":"Tips for modeling for state estimation","text":"When performing state estimation, we need disturbance inputs as indicated above. However, when simulating the model we may want to ignore these. The generally recommended approach is to use a component-based modeling approach. You may then create an outer model in which you connect input components corresponding to the disturbance inputs. For example, in a mechanical system you may in the outer model connect a Rotational.Torque component to a flange in the system model, this gives you an unbound input that adds an external disturbance torque to the flange.\n\nIf you have measured/controlled inputs in the system you follow a similar approach, in the outer model you then\n\nSimulation: Connect an input component that contains the input signal to the system, e.g., an interpolation component.\nState estimation: Leave the disturbance inputs unconnected and pass them to the disturbance_inputs argument.\n\nThis approach also prevents you from accidentally adding disturbances that cause non-physical behavior. For example, perturbing a position without going through a force is not physically realistic, you have to integrate a force or a torque, that in turn affects the velocity which is integrated to the position. You will not find an input component that inputs position, only force and torque, so adding such a non-physical position disturbance is not possible. ","category":"section"}]
}
